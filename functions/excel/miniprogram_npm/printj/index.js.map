{"version":3,"sources":["printj.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["/* printj.js (C) 2016-present SheetJS -- http://sheetjs.com */\n/* vim: set ts=2: */\n/*jshint sub:true, eqnull:true */\n/*exported PRINTJ */\nvar PRINTJ;\n(function (factory) {\n\t/*jshint ignore:start */\n\t/*eslint-disable */\n\tif(typeof DO_NOT_EXPORT_PRINTJ === 'undefined') {\n\t\tif('object' === typeof exports) {\n\t\t\tfactory(exports);\n\t\t} else if ('function' === typeof define && define.amd) {\n\t\t\tdefine(function () {\n\t\t\t\tvar module = {};\n\t\t\t\tfactory(module);\n\t\t\t\treturn module;\n\t\t\t});\n\t\t} else {\n\t\t\tfactory(PRINTJ = {});\n\t\t}\n\t} else {\n\t\tfactory(PRINTJ = {});\n\t}\n\t/*eslint-enable */\n\t/*jshint ignore:end */\n}(function(PRINTJ) {\n\nPRINTJ.version = '1.1.2';\n\nfunction tokenize(fmt) {\n\tvar out = [];\n\tvar start = 0;\n\n\tvar i = 0;\n\tvar infmt = false;\n\tvar fmtparam = \"\", fmtflags = \"\", fmtwidth = \"\", fmtprec = \"\", fmtlen = \"\";\n\n\tvar c = 0;\n\n\tvar L = fmt.length;\n\n\tfor(; i < L; ++i) {\n\t\tc = fmt.charCodeAt(i);\n\t\tif(!infmt) {\n\n\t\t\tif(c !== 37) continue;\n\n\t\t\tif(start < i) out.push([\"L\", fmt.substring(start, i)]);\n\t\t\tstart = i;\n\t\t\tinfmt = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(c >= 48 && c < 58)\t{\n\t\t\t\tif(fmtprec.length) fmtprec += String.fromCharCode(c);\n\t\t\t\telse if(c == 48 && !fmtwidth.length) fmtflags += String.fromCharCode(c);\n\t\t\t\telse fmtwidth += String.fromCharCode(c);\n\t\t} else switch(c) {\n\t\t\t/* positional */\n\t\t\tcase 36:\n\t\t\t\tif(fmtprec.length) fmtprec += \"$\";\n\t\t\t\telse if(fmtwidth.charAt(0) == \"*\") fmtwidth += \"$\";\n\t\t\t\telse { fmtparam = fmtwidth + \"$\"; fmtwidth = \"\"; }\n\t\t\t\tbreak;\n\n\t\t\t/* flags */\n\t\t\tcase 39: fmtflags += \"'\"; break;\n\t\t\tcase 45: fmtflags += \"-\"; break;\n\t\t\tcase 43: fmtflags += \"+\"; break;\n\t\t\tcase 32: fmtflags += \" \"; break;\n\t\t\tcase 35: fmtflags += \"#\"; break;\n\n\t\t\t/* width and precision */\n\t\t\tcase 46: fmtprec = \".\"; break;\n\t\t\tcase 42:\n\t\t\t\tif(fmtprec.charAt(0) == \".\") fmtprec += \"*\";\n\t\t\t\telse fmtwidth += \"*\";\n\t\t\t\tbreak;\n\n\t\t\t/* length */\n\t\t\tcase 104:\n\t\t\tcase 108:\n\t\t\t\tif(fmtlen.length > 1) throw \"bad length \" + fmtlen + String(c);\n\t\t\t\tfmtlen += String.fromCharCode(c);\n\t\t\t\tbreak;\n\n\t\t\tcase  76:\n\t\t\tcase 106:\n\t\t\tcase 122:\n\t\t\tcase 116:\n\t\t\tcase 113:\n\t\t\tcase  90:\n\t\t\tcase 119:\n\t\t\t\tif(fmtlen !== \"\") throw \"bad length \" + fmtlen + String.fromCharCode(c);\n\t\t\t\tfmtlen = String.fromCharCode(c);\n\t\t\t\tbreak;\n\n\t\t\tcase 73:\n\t\t\t\tif(fmtlen !== \"\") throw \"bad length \" + fmtlen + 'I';\n\t\t\t\tfmtlen = 'I';\n\t\t\t\tbreak;\n\n\t\t\t/* conversion */\n\t\t\tcase 100:\n\t\t\tcase 105:\n\t\t\tcase 111:\n\t\t\tcase 117:\n\t\t\tcase 120:\n\t\t\tcase 88:\n\t\t\tcase 102:\n\t\t\tcase 70:\n\t\t\tcase 101:\n\t\t\tcase 69:\n\t\t\tcase 103:\n\t\t\tcase 71:\n\t\t\tcase 97:\n\t\t\tcase 65:\n\t\t\tcase 99:\n\t\t\tcase 67:\n\t\t\tcase 115:\n\t\t\tcase 83:\n\t\t\tcase 112:\n\t\t\tcase 110:\n\t\t\tcase 68:\n\t\t\tcase 85:\n\t\t\tcase 79:\n\t\t\tcase 109:\n\t\t\tcase 98:\n\t\t\tcase 66:\n\t\t\tcase 121:\n\t\t\tcase 89:\n\t\t\tcase 74:\n\t\t\tcase 86:\n\t\t\tcase 84:\n\t\t\tcase 37:\n\t\t\t\tinfmt = false;\n\t\t\t\tif(fmtprec.length > 1) fmtprec = fmtprec.substr(1);\n\t\t\t\tout.push([String.fromCharCode(c), fmt.substring(start, i+1), fmtparam, fmtflags, fmtwidth, fmtprec, fmtlen]);\n\t\t\t\tstart = i+1;\n\t\t\t\tfmtlen = fmtprec = fmtwidth = fmtflags = fmtparam = \"\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"Invalid format string starting with |\" + fmt.substring(start, i+1) + \"|\");\n\t\t}\n\n\t}\n\n\tif(start < fmt.length) out.push([\"L\", fmt.substring(start)]);\n\treturn out;\n}\n\n//#define PAD_(x,c) (x >= 0 ? new Array(((x)|0) + 1).join((c)) : \"\")\nvar padstr = {\n\t\" \": \"                                 \",\n\t\"0\": \"000000000000000000000000000000000\",\n\t\"7\": \"777777777777777777777777777777777\",\n\t\"f\": \"fffffffffffffffffffffffffffffffff\"\n};\n\n/*global process:true, util:true, require:true */\nif(typeof process !== 'undefined' && !!process.versions && !!process.versions.node) util=require(\"util\");\nvar u_inspect = (typeof util != 'undefined') ? util.inspect : JSON.stringify;\n\nfunction doit(t, args) {\n\tvar o = [];\n\tvar argidx = 0, idx = 0;\n\tvar Vnum = 0;\n\tvar pad = \"\";\n\tfor(var i = 0; i < t.length; ++i) {\n\t\tvar m = t[i], c = (m[0]).charCodeAt(0);\n\t\t/* m order: conv full param flags width prec length */\n\n\t\tif(c === /*L*/ 76) { o.push(m[1]); continue; }\n\t\tif(c === /*%*/ 37) { o.push(\"%\"); continue; }\n\n\t\tvar O = \"\";\n\t\tvar isnum = 0, radix = 10, bytes = 4, sign = false;\n\n\t\t/* flags */\n\t\tvar flags = m[3]||\"\";\n\t\tvar alt = flags.indexOf(\"#\") > -1;\n\n\t\t/* position */\n\t\tif(m[2]) argidx = parseInt(m[2])-1;\n\t\t/* %m special case */\n\t\telse if(c === /*m*/ 109 && !alt) { o.push(\"Success\"); continue; }\n\n\t\t/* grab width */\n\t\tvar width =  0; if(m[ 4] != null && m[ 4].length > 0) { if(m[ 4].charAt(0) !== '*') width = parseInt(m[ 4], 10); else if(m[ 4].length === 1) width = args[idx++]; else width = args[parseInt(m[ 4].substr(1), 10)-1]; }\n\n\t\t/* grab precision */\n\t\tvar prec =  -1; if(m[ 5] != null && m[ 5].length > 0) { if(m[ 5].charAt(0) !== '*') prec = parseInt(m[ 5], 10); else if(m[ 5].length === 1) prec = args[idx++]; else prec = args[parseInt(m[ 5].substr(1), 10)-1]; }\n\n\t\t/* position not specified */\n\t\tif(!m[2]) argidx = idx++;\n\n\t\t/* grab argument */\n\t\tvar arg = args[argidx];\n\n\t\t/* grab length */\n\t\tvar len = m[6] || \"\";\n\n\t\tswitch(c) {\n\t\t\t/* str cCsS */\n\n\t\t\tcase /*S*/  83:\n\t\t\tcase /*s*/ 115:\n\t\t\t\t/* only valid flag is \"-\" for left justification */\n\t\t\t\tO = String(arg);\n\t\t\t\tif( prec >= 0) O = O.substr(0,  prec);\n\t\t\t\tif( width > O.length || - width > O.length) { if(( flags.indexOf(\"-\") == -1 ||  width < 0) &&  flags.indexOf(\"0\") != -1) { pad = ( width - O.length >= 0 ? padstr[\"0\"].substr(0, width - O.length) : \"\"); O = pad + O; } else { pad = ( width - O.length >= 0 ? padstr[\" \"].substr(0, width - O.length) : \"\"); O =  flags.indexOf(\"-\") > -1 ? O + pad : pad + O; } }\n\t\t\t\tbreak;\n\n\t\t\t/* first char of string or convert */\n\t\t\tcase /*C*/  67:\n\t\t\tcase /*c*/  99:\n\t\t\t\tswitch(typeof arg) {\n\t\t\t\t\tcase \"number\":\n\t\t\t\t\t\tvar cc = arg;\n\t\t\t\t\t\tif(c == 67 || len.charCodeAt(0) === /*l*/ 108) {  cc &= 0xFFFFFFFF; O = String.fromCharCode( cc); }\n\t\t\t\t\t\telse {  cc &= 0xFF; O = String.fromCharCode( cc); }\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"string\": O = arg.charAt(0); break;\n\t\t\t\t\tdefault: O = String(arg).charAt(0);\n\t\t\t\t}\n\t\t\t\tif( width > O.length || - width > O.length) { if(( flags.indexOf(\"-\") == -1 ||  width < 0) &&  flags.indexOf(\"0\") != -1) { pad = ( width - O.length >= 0 ? padstr[\"0\"].substr(0, width - O.length) : \"\"); O = pad + O; } else { pad = ( width - O.length >= 0 ? padstr[\" \"].substr(0, width - O.length) : \"\"); O =  flags.indexOf(\"-\") > -1 ? O + pad : pad + O; } }\n\t\t\t\tbreak;\n\n\t\t\t/* int diDuUoOxXbB */\n\n\t\t\t/* signed integer */\n\t\t\tcase /*D*/  68: bytes = 8;\n\t\t\t/* falls through */\n\t\t\tcase /*d*/ 100:\n\t\t\tcase /*i*/ 105: isnum = -1; sign = true; break;\n\n\t\t\t/* unsigned integer */\n\t\t\tcase /*U*/  85: bytes = 8;\n\t\t\t/* falls through */\n\t\t\tcase /*u*/ 117: isnum = -1; break;\n\n\t\t\t/* unsigned octal */\n\t\t\tcase /*O*/  79: bytes = 8;\n\t\t\t/* falls through */\n\t\t\tcase /*o*/ 111: isnum = -1; radix = (8); break;\n\n\t\t\t/* unsigned hex */\n\t\t\tcase /*x*/ 120: isnum = -1; radix = (-16); break;\n\t\t\tcase /*X*/  88: isnum = -1; radix = (16); break;\n\n\t\t\t/* unsigned binary (extension) */\n\t\t\tcase /*B*/  66: bytes = 8;\n\t\t\t/* falls through */\n\t\t\tcase /*b*/  98: isnum = -1; radix = (2); break;\n\n\t\t\t/* flt fegFEGaA */\n\n\t\t\t/* floating point logic */\n\t\t\tcase /*F*/  70:\n\t\t\tcase /*f*/ 102: isnum = (1); break;\n\n\t\t\tcase /*E*/  69:\n\t\t\tcase /*e*/ 101: isnum = (2); break;\n\n\t\t\tcase /*G*/  71:\n\t\t\tcase /*g*/ 103: isnum = (3); break;\n\n\t\t\t/* floating hex */\n\t\t\tcase /*A*/  65:\n\t\t\tcase /*a*/  97: isnum = (4); break;\n\n\t\t\t/* misc pnmJVTyY */\n\n\t\t\t/* JS has no concept of pointers so interpret the `l` key as an address */\n\t\t\tcase /*p*/ 112:\n\t\t\t\tVnum = typeof arg == \"number\" ? arg : arg ? Number(arg.l) : -1;\n\t\t\t\tif(isNaN(Vnum)) Vnum = -1;\n\t\t\t\tif(alt) O = Vnum.toString(10);\n\t\t\t\telse {\n\t\t\t\t\tVnum = Math.abs(Vnum);\n\t\t\t\t\tO = \"0x\" + Vnum.toString(16).toLowerCase();\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t/* store length in the `len` key */\n\t\t\tcase /*n*/ 110:\n\t\t\t\tif(arg) { arg.len=0; for(var oo = 0; oo < o.length; ++oo) arg.len += o[oo].length; }\n\t\t\t\tcontinue;\n\n\t\t\t/* process error */\n\t\t\tcase /*m*/ 109:\n\t\t\t\tif(!(arg instanceof Error)) O = \"Success\";\n\t\t\t\telse if(arg.message) O = arg.message;\n\t\t\t\telse if(arg.errno) O = \"Error number \" + arg.errno;\n\t\t\t\telse O = \"Error \" + String(arg);\n\t\t\t\tbreak;\n\n\t\t\t/* JS-specific conversions (extension) */\n\t\t\tcase /*J*/  74: O = (alt ? u_inspect : JSON.stringify)(arg); break;\n\t\t\tcase /*V*/  86: O = arg == null ? \"null\" : String(arg.valueOf()); break;\n\t\t\tcase /*T*/  84:\n\t\t\t\tif(alt) { /* from '[object %s]' extract %s */\n\t\t\t\t\tO = Object.prototype.toString.call(arg).substr(8);\n\t\t\t\t\tO = O.substr(0, O.length - 1);\n\t\t\t\t} else O = typeof arg;\n\t\t\t\tbreak;\n\n\t\t\t/* boolean (extension) */\n\t\t\tcase /*Y*/  89:\n\t\t\tcase /*y*/ 121:\n\t\t\t\tO = Boolean(arg) ? (alt ? \"yes\" : \"true\") : (alt ? \"no\" : \"false\");\n\t\t\t\tif(c == /*Y*/ 89) O = O.toUpperCase();\n\t\t\t\tif( prec >= 0) O = O.substr(0,  prec);\n\t\t\t\tif( width > O.length || - width > O.length) { if(( flags.indexOf(\"-\") == -1 ||  width < 0) &&  flags.indexOf(\"0\") != -1) { pad = ( width - O.length >= 0 ? padstr[\"0\"].substr(0, width - O.length) : \"\"); O = pad + O; } else { pad = ( width - O.length >= 0 ? padstr[\" \"].substr(0, width - O.length) : \"\"); O =  flags.indexOf(\"-\") > -1 ? O + pad : pad + O; } }\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tif(width < 0) { width = -width; flags += \"-\"; }\n\n\t\tif(isnum == -1) {\n\n\t\t\tVnum = Number(arg);\n\n\t\t\t/* parse byte length field */\n\n\t\t\tswitch(len) {\n\t\t\t\t/* char */\n\t\t\t\tcase \"hh\": { bytes = 1; } break;\n\t\t\t\t/* short */\n\t\t\t\tcase \"h\":  { bytes = 2; } break;\n\n\t\t\t\t/* long */\n\t\t\t\tcase \"l\":  { if(bytes == 4) bytes = 8; } break;\n\n\t\t\t\t/* long long */\n\t\t\t\tcase \"L\":\n\t\t\t\tcase \"q\":\n\t\t\t\tcase \"ll\": { if(bytes == 4) bytes = 8; } break;\n\n\t\t\t\t/* intmax_t */\n\t\t\t\tcase \"j\":  { if(bytes == 4) bytes = 8; } break;\n\n\t\t\t\t/* ptrdiff_t */\n\t\t\t\tcase \"t\":  { if(bytes == 4) bytes = 8; } break;\n\n\t\t\t\t/* size_t */\n\t\t\t\tcase \"z\":\n\t\t\t\tcase \"Z\":  { if(bytes == 4) bytes = 8; } break;\n\n\t\t\t\t/* CRT size_t or ptrdiff_t */\n\t\t\t\tcase \"I\":\n\n\t\t\t\t\t{ if(bytes == 4) bytes = 8; }\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t/* CRT wchar_t */\n\t\t\t\tcase \"w\": break;\n\t\t\t}\n\n\t\t\t/* restrict value */\n\n\t\t\tswitch(bytes) {\n\t\t\t\tcase 1: Vnum = (Vnum & 0xFF); if(sign && (Vnum >  0x7F)) Vnum -= (0xFF + 1); break;\n\t\t\t\tcase 2: Vnum = (Vnum & 0xFFFF); if(sign && (Vnum >  0x7FFF)) Vnum -= (0xFFFF + 1); break;\n\t\t\t\tcase 4: Vnum = sign ? (Vnum | 0) : (Vnum >>> 0); break;\n\t\t\t\tdefault: Vnum = isNaN(Vnum) ? 0 : Math.round(Vnum); break;\n\t\t\t}\n\n\t\t\t/* generate string */\n\t\t\tif(bytes > 4 && Vnum < 0 && !sign) {\n\t\t\t\tif(radix == 16 || radix == -16) {\n\t\t\t\t\tO = (Vnum>>>0).toString(16);\n\t\t\t\t\tVnum = Math.floor((Vnum - (Vnum >>> 0)) / Math.pow(2,32));\n\t\t\t\t\tO = (Vnum>>>0).toString(16) + (8 - O.length >= 0 ? padstr[ \"0\"].substr(0,8 - O.length) : \"\") + O;\n\t\t\t\t\tO = (16 - O.length >= 0 ? padstr[ \"f\"].substr(0,16 - O.length) : \"\") + O;\n\t\t\t\t\tif(radix == 16) O = O.toUpperCase();\n\t\t\t\t} else if(radix == 8) {\n\t\t\t\t\tO = (Vnum>>>0).toString(8);\n\t\t\t\t\tO = (10 - O.length >= 0 ? padstr[ \"0\"].substr(0,10 - O.length) : \"\") + O;\n\t\t\t\t\tVnum = Math.floor((Vnum - ((Vnum >>> 0)&0x3FFFFFFF)) / Math.pow(2,30));\n\t\t\t\t\tO = (Vnum>>>0).toString(8) + O.substr(O.length - 10);\n\t\t\t\t\tO = O.substr(O.length - 20);\n\t\t\t\t\tO = \"1\" + (21 - O.length >= 0 ? padstr[ \"7\"].substr(0,21 - O.length) : \"\") + O;\n\t\t\t\t} else {\n\t\t\t\t\tVnum = (-Vnum) % 1e16;\n\t\t\t\t\tvar d1 = [1,8,4,4,6,7,4,4,0,7,3,7,0,9,5,5,1,6,1,6];\n\t\t\t\t\tvar di = d1.length - 1;\n\t\t\t\t\twhile(Vnum > 0) {\n\t\t\t\t\t\tif((d1[di] -= (Vnum % 10)) < 0) { d1[di] += 10; d1[di-1]--; }\n\t\t\t\t\t\t--di; Vnum = Math.floor(Vnum / 10);\n\t\t\t\t\t}\n\t\t\t\t\tO = d1.join(\"\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif(radix === -16) O = Vnum.toString(16).toLowerCase();\n\t\t\t\telse if(radix === 16) O = Vnum.toString(16).toUpperCase();\n\t\t\t\telse O = Vnum.toString(radix);\n\t\t\t}\n\n\t\t\t/* apply precision */\n\t\t\tif(prec ===0 && O == \"0\" && !(radix == 8 && alt)) O = \"\"; /* bail out */\n\t\t\telse {\n\t\t\t\tif(O.length < prec + (O.substr(0,1) == \"-\" ? 1 : 0)) {\n\t\t\t\t\tif(O.substr(0,1) != \"-\") O = (prec - O.length >= 0 ? padstr[ \"0\"].substr(0,prec - O.length) : \"\") + O;\n\t\t\t\t\telse O = O.substr(0,1) + (prec + 1 - O.length >= 0 ? padstr[ \"0\"].substr(0,prec + 1 - O.length) : \"\") + O.substr(1);\n\t\t\t\t}\n\n\t\t\t\t/* add prefix for # form */\n\t\t\t\tif(!sign && alt && Vnum !== 0) switch(radix) {\n\t\t\t\t\tcase -16: O = \"0x\" + O; break;\n\t\t\t\t\tcase  16: O = \"0X\" + O; break;\n\t\t\t\t\tcase   8: if(O.charAt(0) != \"0\") O =  \"0\" + O; break;\n\t\t\t\t\tcase   2: O = \"0b\" + O; break;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* add sign character */\n\t\t\tif(sign && O.charAt(0) != \"-\") {\n\t\t\t\tif(flags.indexOf(\"+\") > -1) O = \"+\" + O;\n\t\t\t\telse if(flags.indexOf(\" \") > -1) O = \" \" + O;\n\t\t\t}\n\t\t\t/* width */\n\t\t\tif(width > 0) {\n\t\t\t\tif(O.length < width) {\n\t\t\t\t\tif(flags.indexOf(\"-\") > -1) {\n\t\t\t\t\t\tO = O + ((width - O.length) >= 0 ? padstr[ \" \"].substr(0,(width - O.length)) : \"\");\n\t\t\t\t\t} else if(flags.indexOf(\"0\") > -1 && prec < 0 && O.length > 0) {\n\t\t\t\t\t\tif(prec > O.length) O = ((prec - O.length) >= 0 ? padstr[ \"0\"].substr(0,(prec - O.length)) : \"\") + O;\n\t\t\t\t\t\tpad = ((width - O.length) >= 0 ? padstr[ (prec > 0 ? \" \" : \"0\")].substr(0,(width - O.length)) : \"\");\n\t\t\t\t\t\tif(O.charCodeAt(0) < 48) {\n\t\t\t\t\t\t\tif(O.charAt(2).toLowerCase() == \"x\") O = O.substr(0,3) + pad + O.substring(3);\n\t\t\t\t\t\t\telse O = O.substr(0,1) + pad + O.substring(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(O.charAt(1).toLowerCase() == \"x\") O = O.substr(0,2) + pad + O.substring(2);\n\t\t\t\t\t\telse O = pad + O;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tO = ((width - O.length) >= 0 ? padstr[ \" \"].substr(0,(width - O.length)) : \"\") + O;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else if(isnum > 0) {\n\n\t\t\tVnum = Number(arg);\n\t\t\tif(arg === null) Vnum = 0/0;\n\t\t\tif(len == \"L\") bytes = 12;\n\t\t\tvar isf = isFinite(Vnum);\n\t\t\tif(!isf) { /* Infinity or NaN */\n\t\t\t\tif(Vnum < 0) O = \"-\";\n\t\t\t\telse if(flags.indexOf(\"+\") > -1) O = \"+\";\n\t\t\t\telse if(flags.indexOf(\" \") > -1) O = \" \";\n\t\t\t\tO += (isNaN(Vnum)) ? \"nan\" : \"inf\";\n\t\t\t} else {\n\t\t\t\tvar E = 0;\n\n\t\t\t\tif(prec == -1 && isnum != 4) prec = 6;\n\n\t\t\t\t/* g/G conditional behavior */\n\t\t\t\tif(isnum == 3) {\n\t\t\t\t\tO = Vnum.toExponential(1);\n\t\t\t\t\tE = +O.substr(O.indexOf(\"e\") + 1);\n\t\t\t\t\tif(prec === 0) prec = 1;\n\t\t\t\t\tif(prec > E && E >= -4) { isnum = (11); prec = prec -(E + 1); }\n\t\t\t\t\telse { isnum = (12); prec = prec - 1; }\n\t\t\t\t}\n\n\t\t\t\t/* sign: workaround for negative zero */\n\t\t\t\tvar sg = (Vnum < 0 || 1/Vnum == -Infinity) ? \"-\" : \"\";\n\t\t\t\tif(Vnum < 0) Vnum = -Vnum;\n\n\t\t\t\tswitch(isnum) {\n\t\t\t\t\t/* f/F standard */\n\t\t\t\t\tcase 1: case 11:\n\t\t\t\t\t\tif(Vnum < 1e21) {\n\t\t\t\t\t\t\tO = Vnum.toFixed(prec);\n\t\t\t\t\t\t\tif(isnum == 1) { if(prec===0 &&alt&& O.indexOf(\".\")==-1) O+=\".\"; }\n\t\t\t\t\t\t\telse if(!alt) O=O.replace(/(\\.\\d*[1-9])0*$/,\"$1\").replace(/\\.0*$/,\"\");\n\t\t\t\t\t\t\telse if(O.indexOf(\".\") == -1) O+= \".\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tO = Vnum.toExponential(20);\n\t\t\t\t\t\tE = +O.substr(O.indexOf(\"e\")+1);\n\t\t\t\t\t\tO = O.charAt(0) + O.substr(2,O.indexOf(\"e\")-2);\n\t\t\t\t\t\tO = O + (E - O.length + 1 >= 0 ? padstr[ \"0\"].substr(0,E - O.length + 1) : \"\");\n\t\t\t\t\t\tif(alt || (prec > 0 && isnum !== 11)) O = O + \".\" + (prec >= 0 ? padstr[ \"0\"].substr(0,prec) : \"\");\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t/* e/E exponential */\n\t\t\t\t\tcase 2: case 12:\n\t\t\t\t\t\tO = Vnum.toExponential(prec);\n\t\t\t\t\t\tE = O.indexOf(\"e\");\n\t\t\t\t\t\tif(O.length - E === 3) O = O.substr(0, E+2) + \"0\" + O.substr(E+2);\n\t\t\t\t\t\tif(alt && O.indexOf(\".\") == -1) O = O.substr(0,E) +\".\"+ O.substr(E);\n\t\t\t\t\t\telse if(!alt && isnum == 12) O = O.replace(/\\.0*e/, \"e\").replace(/\\.(\\d*[1-9])0*e/, \".$1e\");\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t/* a/A hex */\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tif(Vnum===0){O= \"0x0\"+((alt||prec>0)?\".\"+(prec >= 0 ? padstr[\"0\"].substr(0,prec) : \"\"):\"\")+\"p+0\"; break;}\n\t\t\t\t\t\tO = Vnum.toString(16);\n\t\t\t\t\t\t/* First char 0-9 */\n\t\t\t\t\t\tvar ac = O.charCodeAt(0);\n\t\t\t\t\t\tif(ac == 48) {\n\t\t\t\t\t\t\tac = 2; E = -4; Vnum *= 16;\n\t\t\t\t\t\t\twhile(O.charCodeAt(ac++) == 48) { E -= 4; Vnum *= 16; }\n\t\t\t\t\t\t\tO = Vnum.toString(16);\n\t\t\t\t\t\t\tac = O.charCodeAt(0);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar ai = O.indexOf(\".\");\n\t\t\t\t\t\tif(O.indexOf(\"(\") > -1) {\n\t\t\t\t\t\t\t/* IE exponential form */\n\t\t\t\t\t\t\tvar am = O.match(/\\(e(.*)\\)/);\n\t\t\t\t\t\t\tvar ae = am ? (+am[1]) : 0;\n\t\t\t\t\t\t\tE += 4 * ae; Vnum /= Math.pow(16, ae);\n\t\t\t\t\t\t} else if(ai > 1) {\n\t\t\t\t\t\t\tE += 4 * (ai - 1); Vnum /= Math.pow(16, ai - 1);\n\t\t\t\t\t\t} else if(ai == -1) {\n\t\t\t\t\t\t\tE += 4 * (O.length - 1); Vnum /= Math.pow(16, O.length - 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* at this point 1 <= Vnum < 16 */\n\n\t\t\t\t\t\tif(bytes > 8) {\n\t\t\t\t\t\t\tif(ac < 50) { E -= 3; Vnum *= 8; }\n\t\t\t\t\t\t\telse if(ac < 52) { E -= 2; Vnum *= 4; }\n\t\t\t\t\t\t\telse if(ac < 56) { E -= 1; Vnum *= 2; }\n\t\t\t\t\t\t\t/* at this point 8 <= Vnum < 16 */\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif(ac >= 56) { E += 3; Vnum /= 8; }\n\t\t\t\t\t\t\telse if(ac >= 52) { E += 2; Vnum /= 4; }\n\t\t\t\t\t\t\telse if(ac >= 50) { E += 1; Vnum /= 2; }\n\t\t\t\t\t\t\t/* at this point 1 <= Vnum < 2 */\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tO = Vnum.toString(16);\n\t\t\t\t\t\tif(O.length > 1) {\n\t\t\t\t\t\t\tif(O.length > prec+2 && O.charCodeAt(prec+2) >= 56) {\n\t\t\t\t\t\t\t\tvar _f = O.charCodeAt(0) == 102;\n\t\t\t\t\t\t\t\tO = (Vnum + 8 * Math.pow(16, -prec-1)).toString(16);\n\t\t\t\t\t\t\t\tif(_f && O.charCodeAt(0) == 49) E += 4;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(prec > 0) {\n\t\t\t\t\t\t\t\tO = O.substr(0, prec + 2);\n\t\t\t\t\t\t\t\tif(O.length < prec + 2) {\n\t\t\t\t\t\t\t\t\tif(O.charCodeAt(0) < 48) O = O.charAt(0) + ((prec + 2 - O.length) >= 0 ? padstr[ \"0\"].substr(0,(prec + 2 - O.length)) : \"\") + O.substr(1);\n\t\t\t\t\t\t\t\t\telse O += ((prec + 2 - O.length) >= 0 ? padstr[ \"0\"].substr(0,(prec + 2 - O.length)) : \"\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if(prec === 0) O = O.charAt(0) + (alt ? \".\" : \"\");\n\t\t\t\t\t\t} else if(prec > 0) O = O + \".\" + (prec >= 0 ? padstr[\"0\"].substr(0,prec) : \"\");\n\t\t\t\t\t\telse if(alt) O = O + \".\";\n\t\t\t\t\t\tO = \"0x\" + O + \"p\" + (E>=0 ? \"+\" + E : E);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif(sg === \"\") {\n\t\t\t\t\tif(flags.indexOf(\"+\") > -1) sg = \"+\";\n\t\t\t\t\telse if(flags.indexOf(\" \") > -1) sg = \" \";\n\t\t\t\t}\n\n\t\t\t\tO = sg + O;\n\t\t\t}\n\n\t\t\t/* width */\n\t\t\tif(width > O.length) {\n\t\t\t\tif(flags.indexOf(\"-\") > -1) {\n\t\t\t\t\tO = O + ((width - O.length) >= 0 ? padstr[ \" \"].substr(0,(width - O.length)) : \"\");\n\t\t\t\t} else if(flags.indexOf(\"0\") > -1 && O.length > 0 && isf) {\n\t\t\t\t\tpad = ((width - O.length) >= 0 ? padstr[ \"0\"].substr(0,(width - O.length)) : \"\");\n\t\t\t\t\tif(O.charCodeAt(0) < 48) {\n\t\t\t\t\t\tif(O.charAt(2).toLowerCase() == \"x\") O = O.substr(0,3) + pad + O.substring(3);\n\t\t\t\t\t\telse O = O.substr(0,1) + pad + O.substring(1);\n\t\t\t\t\t}\n\t\t\t\t\telse if(O.charAt(1).toLowerCase() == \"x\") O = O.substr(0,2) + pad + O.substring(2);\n\t\t\t\t\telse O = pad + O;\n\t\t\t\t} else {\n\t\t\t\t\tO = ((width - O.length) >= 0 ? padstr[ \" \"].substr(0,(width - O.length)) : \"\") + O;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c < 96) O = O.toUpperCase();\n\n\t\t}\n\n\t\to.push(O);\n\t}\n\treturn o.join(\"\");\n}\n\nfunction vsprintf(fmt, args) { return doit(tokenize(fmt), args); }\n\nfunction sprintf() {\n\tvar args = new Array(arguments.length - 1);\n\tfor(var i = 0; i < args.length; ++i) args[i] = arguments[i+1];\n\treturn doit(tokenize(arguments[0]), args);\n}\n\nPRINTJ.sprintf = sprintf;\nPRINTJ.vsprintf = vsprintf;\nPRINTJ._doit = doit;\nPRINTJ._tokenize = tokenize;\n\n}));\n\n"]}